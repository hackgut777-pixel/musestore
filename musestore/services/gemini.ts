
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/
import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export async function editImage(imageBase64: string, prompt: string): Promise<string> {
  // Ensure we have raw base64 data
  const base64Data = imageBase64.includes(',') ? imageBase64.split(',')[1] : imageBase64;
  
  // Try to detect mime type from header, default to jpeg if missing
  let mimeType = imageBase64.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/)?.[1] || 'image/jpeg';

  // Normalize common mime type issues
  if (mimeType === 'image/jpg') mimeType = 'image/jpeg';

  // Enforce strict image generation instruction
  const strictPrompt = `Edit this image based on the following instruction. output only the image. Instruction: ${prompt}`;

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: [
        {
          parts: [
            {
              inlineData: {
                data: base64Data,
                mimeType: mimeType
              }
            },
            { text: strictPrompt }
          ]
        }
      ]
    });

    // Iterate through parts to find the image
    const parts = response.candidates?.[0]?.content?.parts || [];
    for (const part of parts) {
      if (part.inlineData && part.inlineData.data) {
        // Gemini usually returns image/png for generated images
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }
    
    // If no inlineData, check if there's text explaining why
    const textPart = parts.find(p => p.text);
    if (textPart) {
        console.warn("Gemini returned text instead of image:", textPart.text);
        throw new Error(`The model returned text: ${textPart.text}`);
    }

    throw new Error("No image generated by the model.");
  } catch (error: any) {
    console.error("Gemini Image Edit Error:", error);
    // Provide more helpful error message for 400s
    if (error.message?.includes('400') || error.status === 400) {
        throw new Error("Invalid request. The image might be too large, the format unsupported, or the prompt violates safety policies.");
    }
    throw error;
  }
}

export async function chatWithGemini(history: {role: 'user' | 'model', parts: {text: string}[]}[], message: string): Promise<string> {
  try {
    const chat = ai.chats.create({
      model: 'gemini-3-pro-preview',
      history: history,
      config: {
        systemInstruction: "You are the MUSE Concierge, an AI assistant for a high-end luxury bag brand called MUSE. Your tone is sophisticated, polite, helpful, and concise. You assist customers with styling advice, product inquiries, and brand information. Keep your responses suitable for a chat interface (short and engaging).",
      }
    });

    const result = await chat.sendMessage({ message });
    return result.text || "I apologize, I am unable to formulate a response at this moment.";
  } catch (error) {
    console.error("Chat Error:", error);
    return "I apologize, the concierge service is currently unavailable. Please try again later.";
  }
}
